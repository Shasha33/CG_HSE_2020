// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ComputeHarmonics

#define PI            3.14159265359f
#define TWO_PI        6.28318530718f
#define FOUR_PI       12.56637061436f
#define INV_PI        0.31830988618f
#define INV_TWO_PI    0.15915494309f
#define INV_FOUR_PI   0.07957747155f
#define HALF_PI       1.57079632679f
#define INV_HALF_PI   0.636619772367f

RWStructuredBuffer<float4> SH_0_1_r;
RWStructuredBuffer<float4> SH_0_1_g;
RWStructuredBuffer<float4> SH_0_1_b;

RWStructuredBuffer<float4> SH_2_r;
RWStructuredBuffer<float4> SH_2_g;
RWStructuredBuffer<float4> SH_2_b;

RWStructuredBuffer<float4> SH_2_rgb;

TextureCube<half4> _Env;
SamplerState samplerLinearRepeat;

#include <UnityCG.cginc>

uint Hash(uint s)
{
    s ^= 2747636419u;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    return s;
}

float Random(uint seed)
{
    return float(Hash(seed)) / 4294967295.0; // 2^32-1
}

float3 SampleColor(float3 direction)
{   
    float4 tex = _Env.SampleLevel(samplerLinearRepeat, direction, 0);
    return tex.rgb;
}

float Klm(int l, int m) {
    switch (l) {
        case 0:
            return 1 / (2 * sqrt(PI));
        case 1:
            switch (m) {
                case -1:
                    return - sqrt(3) / (2 * sqrt(PI)); 
                case 0:
                    return sqrt(3) / (2 * sqrt(PI));
                case 1:
                    return - sqrt(3) / (2 * sqrt(PI));
            };
            break;
           
        case 2: 
            switch (m) {
                case -2:
                    return sqrt(15) / (2 * sqrt(PI));
                case -1:
                    return - sqrt(15) / (2 * sqrt(PI));
                case 0:
                    return sqrt(5) / (4 * sqrt(PI));
                case 1:
                    return sqrt(15) / (2 * sqrt(PI));
                case 2:
                    return sqrt(15) / (4 * sqrt(PI));
            }
            break;
    };
    return 0;
}

float Plm(int l, int m, float3 w) {
    switch (l) {
        case 0:
            return 1;
        case 1:
            switch (m) {
                case -1:
                    return w.y; 
                case 0:
                    return w.z;
                case 1:
                    return w.x;
            };
            break;
           
        case 2: 
            switch (m) {
                case -2:
                    return w.y * w.x;
                case -1:
                    return w.y * w.z;
                case 0:
                    return (3 * w.z*w.z - 1);
                case 1:
                    return w.x * w.z;
                case 2:
                    return (w.x*w.x - w.y*w.y);
            }
            break;
    };
    return 0;
}


float Harmonic(int l, int m, float3 w) {
    return Klm(l, m) * Plm(l, m, w);
}

[numthreads(1024, 1, 1)]
void ComputeHarmonics(uint id : SV_DispatchThreadID)
{
    const int THREADS = 1024;
    const int SAMPLES = 100;
    
    
    // Populate results buffer using monte-carlo method.
    // You can see the Random(i) function. Use it just as with the previous task.
    
    // TASK: project light from _Env to spherical harmonic coefficients and store them in results[]
    
    int N = 100;

    float3 resultColor[3][6]; 
    for (int l = 0; l < 3; l++) {
        for (int m = 0; m < 6; m++) {
            resultColor[l][m] = float3(0, 0, 0);
        }
    }

    float Al[3] = {sqrt(4 * PI) * sqrt(PI) / 2,
                     sqrt(4 * PI / 3) * sqrt(PI / 3),
                      sqrt(4 * PI / 5) * sqrt(5 * PI / 8)};

    for (int i = 0; i < N; i++) {
        float theta = Random(2*i) * PI;
        float alpha = Random(2*i + 1) * TWO_PI;
        float3 w = float3(sin(theta) * cos(alpha), sin(theta)  * sin(alpha), cos(theta));
        float3 sampleColor = SampleColor(w);
        
        for (int l = 0; l < 3; l++) {
            for (int m = -l; m <= l; m++) {
                resultColor[l][m + 2] += sampleColor * Harmonic(l, m, w);
            }
        }
    }

    for (int l = 0; l < 3; l++) {
        for (int m = -l; m <= l; m++) {
            resultColor[l][m + 2] /= N;
            resultColor[l][m + 2] *= 1 / PI * Al[l] * Klm(l, m);
        }
    }

    // See SH.shader for more details
    float4 results[7] = {
        float4(resultColor[1][1 + 2].r, resultColor[1][-1 + 2].r, resultColor[1][0 + 2].r, resultColor[0][0 + 2].r), // SH_0_1_r
        float4(resultColor[1][1 + 2].g, resultColor[1][-1 + 2].g, resultColor[1][0 + 2].g, resultColor[0][0 + 2].g), // SH_0_1_g
        float4(resultColor[1][1 + 2].b, resultColor[1][-1 + 2].b, resultColor[1][0 + 2].b, resultColor[0][0 + 2].b), // SH_0_1_b
        
        float4(resultColor[2][-2 + 2].r, resultColor[2][-1 + 2].r, resultColor[2][1 + 2].r, resultColor[2][0 + 2].r), // SH_2_r
        float4(resultColor[2][-2 + 2].g, resultColor[2][-1 + 2].g, resultColor[2][1 + 2].g, resultColor[2][0 + 2].g), // SH_2_g
        float4(resultColor[2][-2 + 2].b, resultColor[2][-1 + 2].b, resultColor[2][1 + 2].b, resultColor[2][0 + 2].b), // SH_2_b
        
        float4(resultColor[2][2 + 2].r, resultColor[2][2 + 2].g, resultColor[2][2 + 2].b, 0), // SH_2_rgb
    };

    SH_0_1_r[id] = results[0];
    SH_0_1_g[id] = results[1];
    SH_0_1_b[id] = results[2];
    
    SH_2_r[id] = results[3];
    SH_2_g[id] = results[4];
    SH_2_b[id] = results[5];    
    
    SH_2_rgb[id] = results[6];
}